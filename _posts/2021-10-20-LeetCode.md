---
layout:     post                    # 使用的布局（不需要改）
title:      LeetCode刷题笔记             # 标题 
subtitle:   LeetCode Notes  #副标题
date:       2021-10-20              # 时间
author:     Henry                      # 作者
header-img: img/home-bg-geek.jpg   #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - Notes
---

## LeetCode刷题：

### 1、单链表

#### 1.1、合并两个单链表（21题）

![image-20211021203446366](https://tva1.sinaimg.cn/large/008i3skNgy1gvohfhsq0cj61ab0u0jvn02.jpg)

代码如下：

```c++
//21、合并两个有序链表
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode(-1);
        ListNode* p = dummy; // 作为前面一个虚拟节点，其中的p是在不断移动的

        // 输入的两个节点给输入进去（其头指针的位置）
        ListNode* p1 = l1;
        ListNode* p2 = l2;

        while(p1 != nullptr && p2 != nullptr){
            if(p1->val > p2->val){
                p->next = p2;
                p2 = p2->next;
            }else{
                p->next = p1;
                p1 = p1->next;
            }

            p = p->next;
        }

        // 要是输入其中的有一个是空指针
        if(p1 != nullptr){
            p->next = p1;
        }

        if(p2 != nullptr){
            p->next = p2;
        }

        return dummy->next;
    }
};
```

#### 1.2、合并 k 个有序链表（23题）

![image-20211021204449087](https://tva1.sinaimg.cn/large/008i3skNgy1gvohflzsjsj616f0u0n0o02.jpg)

代码如下：

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
 
class Solution{
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        std::priority_queue<ListNode*, std:: vector<ListNode*>, ListNodeCompare> pq;

        // 遍历lists中的所有元素，加塞到优先队列中
        for(const auto& node: lists){
            if(node){ // 可能有些lists中的有些元素是null的
                pq.push(node);
            }
        }

        // 虚拟节点的构建
        ListNode* dummy = new ListNode();
        ListNode* curr = dummy;
        while(pq.size()){ // 只要其中的优先队列不为空
            ListNode* top = pq.top();
            pq.pop();
            curr->next = top;
            curr = curr->next;
            if(top->next){
                pq.push(top->next);
            }
        }
        return dummy->next;
    }
private:
    // 这种写法还没有学过，要注意记一下，在原有的list中是采用传入地址，但是传入的地址并不能比较大小，只能是将地址翻译为实际的数的大小并做比较
    struct ListNodeCompare{
        bool operator()(const ListNode* lhs, const ListNode* rhs){
            return lhs -> val > rhs->val; // 这种函数就是返回其中的比较结果而已
        }
    }
}
```

#### 1.3、单链表的倒数第k个节点（19题）

![image-20211022215725952](https://tva1.sinaimg.cn/large/008i3skNgy1gvohfporzcj613h0u0tc202.jpg)

```c++
ListNode* findFromEnd(ListNode* head, int k){
    ListNode* p1 = head;
    for(int i = 0; i < k; i++){
        p1 = p1->next;
    }

    ListNode* p2 = head;
    while(p1 != nullptr){
        p2 = p2->next;
        p1 = p1->next;
    }

    return p2;
}
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // 虚拟节点的构建
        ListNode* dummy = new ListNode();
        dummy->next = head;
        ListNode* x = findFromEnd(dummy, n + 1);
        // 删除节点的方法
        x->next = x->next->next;
        return dummy->next;
    }

private:
    ListNode* findFromEnd(ListNode* head, int k){
        ListNode* p1 = head;
        for(int i = 0; i < k; i++){
            p1 = p1->next;
        }

        ListNode* p2 = head;
        while(p1 != nullptr){
            p2 = p2->next;
            p1 = p1->next;
        }

        return p2;
    }
};
```

#### 1.4、单链表的中点（876题）

![image-20211022224805197](https://tva1.sinaimg.cn/large/008i3skNgy1gvohfvdgl0j60zs0u0mzh02.jpg)

![image-20211022224849121](https://tva1.sinaimg.cn/large/008i3skNgy1gvohfz0dtwj619t0u0tbf02.jpg)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while(fast != nullptr && fast->next != nullptr){
            slow = slow->next;
            fast = fast->next->next;
        }

        return slow;
    }
};
```


### Reference

- [1] [labuladong的算法小抄]](https://labuladong.gitee.io/algo)